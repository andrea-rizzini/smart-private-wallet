# Smart-private-wallet
This project comprises two demos, originally there were three but the one showing the onboarding feature has been removed for redundancy, since the feature is present in both ```version2_private_transfers``` and ```version2_private_transfers_POI```
1) ```version2_private_transfers```, which allows private transfers and private onboarding in Ethereum.
2) ```version2_private_transfers_POI```, which allows private transfers and private onboarding in Ethereum as ```version2_private_transfers```, but the onboarding happens directly inside the mixer, without the need to shield the fund once redeemed. Also a Proof of Innocence check is present.

# How version2_POI works:
This version relies on a Mixer that is used both for Onboarding and Transfers, both are UTXO-based with UTXOs being appended on the same Merkle Tree.  
Foreword: when a smart contract is created for a user registering in this system, automatically an event on the ```PoolUser``` contract is created, appending a public key associated with that smart contract address; this key is needed by anyone else who want transact with that user privately.  
1) Onboarding: if Alice wants onboard Bob with 0.01 USDC, she has first to create an UTXO for Bob encrypted with a key generated by her, since Bob does not already exist and so his public key. This key will be transmitted in a link together with other information; when Bob clicks the link to onboard, he will find this key among the link data, and with that, he has now control on that UTXO.  
Note that Bob has to trust Alice who also knows the key, but since she is the one who sent money to him, there is no reason to doubt; also usually onboarding regards small amount of money being sent.
2) Transfers: after Bob being onboarded by Alice, they can now transact each other privately. For instace let's suppose Alice wants send 0.01 USDC to Bob privately: she has first to check her UTXOs with her private viewing key in the Merkle Tree and then she has to check if their total amout is greater or equal than the amount she wants send to Bob. If so, she takes those UTXOs as inputs, she creates two UTXOs as outputs (one for Bob encrypted with his public key and the other is her possible change) together with a zero-knowledge proof which proofs her ownership to that UTXOs, then appends them to the Mixer contract. Now the contract verifies the proof and if correct, nullify that input UTXOs. The result is a new UTXO for Bob, that only he is able to see thith his private viewing key.
3) POI: with POI an user who wants withdraw proofs if the corresponding UTXO are allowed or illicit. When a user creates a new UTXO on the Merkle tree, new leafs on another tree with the same height are appended with value "allowed" or "illicit" at the same indixes, based on a legit check (this mechanism is called "add with delay"). When a user wants to withdraw to an external address he also needs to proof if all the UTXOs he includes are on a leaf with "allowed" as value in this second merkle tree. He is forced by the wallet to put all the UTXO he wants include as "allowed" when generating the proof; in this way when the root is checked by the verifier if one of the UTXO he inclueds is actually "illicit" as a value, the check will fail and he won't be able to withdraw.

# Quickstart for version2_POI:
1) ```npm i``` on the root of the project
2) Make sure to have as many private keys as you need and add them to the .env file  
To test the demo you need at least: two users, a faucet and a relayer; hence at least four private keys
3) Make sure to have enough funds on your faucet
4) Circuits setup:  
```cd circuits```  
Execute ```./script_v2.sh 2```  
Execute ```./script_v2.sh 16```   
Execute ```./script_v3.sh 2```  
Execute ```./script_v3.sh 16``` 
A folder ```/artifacts``` inside ```/circuits``` will be created with the compiled circom stuff needed to generate zk-proofs and verification, from that folder move ```Verifier2.sol```, ```Verifier16.sol```, ```VerifierPOI2.sol``` and ```VerifierPOI16.sol``` into the folder ```contracts/src/Compliance/```  
You will have to modify the .sol files with the correct declaration name, since circom will generate all the verifier contract as ```contract Verifier [...]```  
f.i.: ```Verifier2.sol```: ```contract Verifier [...]``` --> ```contract Verifier2 [...]```  
f.i.: ```VerifierPOI2.sol```: ```contract Verifier [...]``` --> ```contract VerifierPOI2 [...]```  
Also rename ```verifyProof``` in ```verifyPOI2``` and ```verifyPOI16``` in POI verifier contracts, to avoid collisions in function names.
5) Base contract setup:   
Deploy ```Paymaster``` and ```AccountFactory``` using ```npx hardhat run ./contracts/scripts/deployPaymasterAndAccFactory.ts```    
6) Mixer setup (that is unique for onboarding and transfers):      
Deploy ```PoolUsers``` using ```npx hardhat run ./contracts/scripts/Transfers/deployPoolUsers.ts```  
Deploy ```EncryptedDataOnboardedUsers ``` using ```npx hardhat run ./contracts/scripts/Transfers/deployEncryptedDataOnboardedUsers.ts```
Deploy ```Hasher``` for the mixer using ```npx hardhat run ./contracts/scripts/Transfers/deployHasherForTransactions.ts```  
Deploy ```Verifier2``` and ```Verifier16``` using ```npx hardhat run ./contracts/scripts/Transfers/deployVerifiers.ts```  
Deploy ```MixerOnboardingAndTransfers``` using ```npx hardhat run ./contracts/scripts/Transfers/deployMixerOnboardingAndTransfers.ts```  
Deploy ```Relayer``` for version2 using  ```npx hardhat run ./contracts/scripts/Transfers/deployRelayer.ts```  
7) Initialize the database:   
```npx hardhat run ./apps/version2_private_transfers_POI/database/initialize_db.ts``` 
Note: a ```.db``` file will be created inside ```/apps/version2_private_transfers_POI/data/```;  if you want initialize a new database, you just have to execute the script ```npx hardhat run /apps/version2_private_transfers_POI/database/deleteDB.ts``` and execute again the command above.
9) Start the program from the root of the project, with:
 ```npx hardhat run ./apps/version2_private_transfers_POI/main.ts```  

# Demo for version2_POI:
You need 2 terminals, T1 and T2.
1) (T1): ```npx hardhat run apps/version2_private_transfers_POI/main.ts```  
2) (T1): type ```1```, type ```testnet``` and choose username (Alice) and password for your account: you will be fund in seconds with 0.01 USDC from the faucet.
3) (T1): type  ```1``` to check your smart contract address and your private balance
4) (T1): in the menu type ```2``` to invite someone, select a name (Bob) for him and select the amount you want onboard him with. You can check your amount after having spent funds to onboard Bob typing  ```1```.
5) (T2): ```npx hardhat run apps/version2_private_transfers_POI/main.ts``` 
6) (T2): type ```3```, choose username (Bob) and password and wait for the onboarding to be complete: now you are in.
7) (T2): in the menu type ```6``` to verify if the person who invited you is present in the contacts (there should be Alice with her address).
8) (T1): in the menu type ```7``` to refresh, this will check if the user has completed the onboarding procedure. 
9) (T1): in the menu type ```7``` to verify if the person you have onboarded is now present in your contacts (there should be Bob with his address).
10) (T1): if you need to fund your private amount, in the menu type ```3``` and then insert the amount you want make private and press enter.
11) (T1): in the menu type ```4```, insert an amount, then you can decide to send to a contact of yours or to send directly by inserting the address, finally you can decide if use a relayer for the send.
12) (T2): in the menu type ```1``` and verify if you have received the amount sent you by Alice.
13) (T2): in the menu type ```5``` to withdraw specifying first the amount in USDC, then the address of the wallet you want withdraw in.
14) (T2): in the menu type ```2``` and verify if the withdrawal has gone well. You can also check on BaseScan if the address you have specified have received the fund.

# Notes:
- You can decide to deploy the contracts on the chain you prefer, all you have to do is to modify the file ```hardhat.config.ts``` specifying the RPC_URL and adding the relevant ```PRIVATE_KEYs``` (with the same name you'll specify them on the .env file).  
View the following example:  

```
const config: HardhatUserConfig = {
  defaultNetwork: "base",
  networks: {
    base: {
      url: process.env.RPC_URL_BASE_SEPOLIA!,
      accounts: [
        process.env.PRIVATE_KEY_ALICE!,
        process.env.PRIVATE_KEY_BOB!,
        process.env.PRIVATE_KEY_FAUCET!,
        process.env.PRIVATE_KEY_RELAYER!,
      ],
    },  
```
  
- You need also to specify your etherscan api key in the file ```hardhat.config.ts```:
```
...

etherscan: {
    apiKey: process.env.ETHERSCAN_API_KEY, 
  },

...
```
- The solidity version which has been used in the project is version ```0.8.12```, in case you need multiple solidity versions check at: https://hardhat.org/hardhat-runner/docs/advanced/multiple-solidity-versions
- For the version_3, you need to specify in the ```.env``` file an API key for the network you are interfacing with. For instance ```ALCHEMY_API_KEY=qwerty1234```